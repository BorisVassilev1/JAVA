#version 450

#ifdef GL_ES
precision highp float;
#endif

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform vec2 resolution;

vec3 cam_pos = vec3(0.5,0.5,-0.6);

vec3 light = vec3(1.5,2.6,0.4);

vec2 v00 = vec2(-1.0,-1.0);
vec2 v01 = vec2(-1.0,1.0);
vec2 v11 = vec2(1.0,1.0);
vec2 v10 = vec2(1.0,-1.0);

struct Sphere {
	vec3 pos;
	float radius;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct RayHit
{
    vec3 position;
    float distance;
    vec3 normal;
};

bool intersectSphere(in Ray ray, in Sphere s, out RayHit hit) {
	return vec3(0.0,0.0,0.0);
}

bool intersectGroundPlane(in Ray ray, in float PlaneHeight, out RayHit hit) {
	
	float t = ray.origin / -ray.direction.y;
	if(t > 0) {
		hit.position = ray.origin + ray.direction * t;
		hit.distance = t;
		hit.normal = vec3(0.0,1.0,0.0);	
	}
}

vec3 lerp(vec3 v00, vec3 v10, vec3 v01, vec3 v11, float x, float y) {
	return mix(
	mix(v00,v10,x),
	mix(v01,v11,x),
	y
	);
}

Sphere sphs[3] = Sphere[3](
	Sphere(vec3(0.5,1.3,1.5),0.5),
	Sphere(vec3(1.3,0.2,2),0.7),
	Sphere(vec3(-0.4,0.5,2),0.5)
);

float angleBetween(vec3 v1, vec3 v2) {
    return acos(dot(normalize(v1), normalize(v2))) / 3.14;
}

void main() {
  vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  
  pixel = vec4(pixel_coords / resolution, 0.0, 1.0);
  
  vec3 direction = 
  
  
  imageStore(img_output, pixel_coords, pixel);
}