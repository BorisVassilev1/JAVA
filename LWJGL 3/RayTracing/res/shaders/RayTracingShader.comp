#version 450

#ifdef GL_ES
precision highp float;
#endif

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

layout(binding = 1) buffer shader_data {
	vec4 sph;
};

uniform mat4 cameraMatrix;
uniform vec2 resolution;
uniform float fov;
uniform int deltaTime;

vec3 cam_pos = vec3(0.0,0.0,0.0);

vec3 light = vec3(1.5,2.6,0.4);

vec3 v00 = vec3(-1.0,-1.0, cos(fov/2));
vec3 v01 = vec3(-1.0, 1.0, cos(fov/2));
vec3 v11 = vec3( 1.0, 1.0, cos(fov/2));
vec3 v10 = vec3( 1.0,-1.0, cos(fov/2));

struct Sphere {
	vec3 position;
	float radius;
	vec3 color;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};

Ray createRay(vec3 origin, vec3 direction) {
	Ray ray = Ray(origin, direction);
	return ray;
}

struct RayHit
{
    vec3 position;
    float distance;
    vec3 normal;
    Sphere object;
};

bool intersectSphere(in Ray ray, in Sphere sphere, inout RayHit hit) {
	// Calculate distance along the ray where the sphere is intersected
    vec3 d = ray.origin - sphere.position;
    float p1 = -dot(ray.direction, d);
    float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;
    if (p2sqr < 0)
        return false;
    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < hit.distance)
    {
        hit.distance = t;
        hit.position = ray.origin + t * ray.direction;
        hit.normal = normalize(hit.position - sphere.position);
        hit.object = sphere;
    }
}

bool intersectGroundPlane(in Ray ray, in float PlaneHeight, inout RayHit hit) {
	
	float t = (ray.origin.y - PlaneHeight) / -ray.direction.y;
	if(t > 0 && t < hit.distance) {
		hit.position = ray.origin + ray.direction * t;
		hit.distance = t;
		if(ray.direction.y < PlaneHeight) hit.normal = normalize(vec3(0.0,1.0,0.0));
		else hit.normal = normalize(vec3(0.0,-1.0,0.0));
		hit.object = Sphere(vec3(0.0,0.0,0.0),0.0,vec3(1.0,1.0,1.0));
		return true;	
	}
	return false;
}

vec3 lerp4vec(vec3 v00, vec3 v10, vec3 v01, vec3 v11, float x, float y) {
	return mix(
	mix(v00,v10,x),
	mix(v01,v11,x),
	y
	);
}

Sphere sphs[5] = Sphere[5](
	Sphere(vec3(0.5,1.3,1.5),0.5 ,vec3(1.0,0.0,0.0)),
	Sphere(vec3(1.3,0.2,2)  ,0.7 ,vec3(0.0,1.0,0.0)),
	Sphere(vec3(-0.4,0.5,1.5) ,0.5 ,vec3(0.0,0.0,1.0)),
	Sphere(vec3(1.5,2.6,0.4) ,0.1 ,vec3(1.0,1.0,0.0)),
	Sphere(sph.xyz, 0.5, sph.xyz)
);

float angleBetween(vec3 v1, vec3 v2) {
    return acos(dot(normalize(v1), normalize(v2))); /// 3.14159;
}

void main() {
  vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  vec2 pixel_position = pixel_coords / resolution;
  cam_pos = (cameraMatrix * vec4(0.0,0.0,0.0,1.0)).xyz;
  
  v00 = (vec4(v00,0.0) * cameraMatrix).xyz;
  v10 = (vec4(v10,0.0) * cameraMatrix).xyz;
  v01 = (vec4(v01,0.0) * cameraMatrix).xyz;
  v11 = (vec4(v11,0.0) * cameraMatrix).xyz;
  
  Ray ray = createRay(cam_pos, normalize( lerp4vec( v00, v10, v01, v11, pixel_position.x, pixel_position.y) ) );
  ray.direction.y *= -1;
  
  
	RayHit hit;
	float mult = 1.0;
	vec3 color = vec3(1.0,1.0,1.0);
	for(int i = 0; i < 10; i ++) {
		hit.distance = 1.0 / 0.0;
		intersectGroundPlane(ray,0.0,hit);
		intersectSphere(ray, sphs[0], hit);
		intersectSphere(ray, sphs[1], hit);
		intersectSphere(ray, sphs[2], hit);
		//intersectSphere(ray, sphs[3], hit);
		intersectSphere(ray, sphs[4], hit);
		if(hit.distance != 1.0/0.0) {
			
			ray.direction = reflect(ray.direction,hit.normal);
			
			Ray toLight = Ray(vec3(hit.position + hit.normal * 0.00001),normalize(+light - hit.position));
			//Ray toLight = Ray(vec3(hit.position + hit.normal * 0.00001),normalize(vec3(0.0,1.0,0.0)));

			RayHit shadowHit;
			shadowHit.distance = 1.0/0.0;
			intersectGroundPlane(toLight,0.0,shadowHit);
			intersectSphere(toLight, sphs[0], shadowHit);
			intersectSphere(toLight, sphs[1], shadowHit);
			intersectSphere(toLight, sphs[2], shadowHit);
			//intersectSphere(toLight, sphs[3], shadowHit);
			intersectSphere(ray, sphs[4], hit);
			
			if(shadowHit.distance != 1.0/0.0) {
				float shadowAngle = angleBetween(hit.normal, toLight.direction);
				mult *= 0;//cos(shadowAngle - 3.14 / 2);
			} 
			else {
				float angle = angleBetween(hit.normal,toLight.direction);
				mult *=  cos(angle);
			}
			if(i == 0) color = hit.object.color;
			color = color * 0.5 + hit.object.color * 0.5;
			
			ray.origin = hit.position + hit.normal * 0.00001;
		}
		//else mult = 0.0;
	}
  	pixel = vec4(color * mult,1.0 );
  imageStore(img_output, pixel_coords, pixel);
}
