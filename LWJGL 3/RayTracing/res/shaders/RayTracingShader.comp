#version 450

#ifdef GL_ES
precision highp float;
#endif


struct Sphere {
	vec4 position;
	vec4 color;
	float radius;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct RayHit
{
    vec3 position;
    float distance;
    vec3 normal;
    Sphere object;
};

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;


layout(std430) buffer shader_data {
	Sphere sphs[];
};

uniform mat4 cameraMatrix;
uniform vec2 resolution;
uniform float fov;
uniform int deltaTime;

vec3 cam_pos = vec3(0.0,0.0,0.0);

vec3 light = vec3(1.5,2.6,0.4);

float aspect = resolution.x / resolution.y;

vec3 v00 = vec3(-1.0 * aspect,-1.0, cos(fov/2));
vec3 v01 = vec3(-1.0 * aspect, 1.0, cos(fov/2));
vec3 v11 = vec3( 1.0 * aspect, 1.0, cos(fov/2));
vec3 v10 = vec3( 1.0 * aspect,-1.0, cos(fov/2));

Ray createRay(vec3 origin, vec3 direction) {
	Ray ray = Ray(origin, direction);
	return ray;
}

bool intersectSphere(in Ray ray, in Sphere sphere, inout RayHit hit) {
	// Calculate distance along the ray where the sphere is intersected
    vec3 d = ray.origin - sphere.position.xyz;
    float p1 = -dot(ray.direction, d);
    float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;
    if (p2sqr < 0)
        return false;
    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < hit.distance)
    {
        hit.distance = t;
        hit.position = ray.origin + t * ray.direction;
        hit.normal = normalize(hit.position - sphere.position.xyz);
        hit.object = sphere;
    }
}

bool intersectGroundPlane(in Ray ray, in float PlaneHeight, inout RayHit hit) {
	
	float t = (ray.origin.y - PlaneHeight) / -ray.direction.y;
	if(t > 0 && t < hit.distance) {
		hit.position = ray.origin + ray.direction * t;
		hit.distance = t;
		if(ray.direction.y < PlaneHeight) hit.normal = normalize(vec3(0.0,1.0,0.0));
		else hit.normal = normalize(vec3(0.0,-1.0,0.0));
		hit.object = Sphere(vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,0.0),0.0);
		return true;	
	}
	return false;
}

vec3 lerp4vec(vec3 v00, vec3 v10, vec3 v01, vec3 v11, float x, float y) {
	return mix(
	mix(v00,v10,x),
	mix(v01,v11,x),
	y
	);
}

float angleBetween(vec3 v1, vec3 v2) {
    return acos(dot(normalize(v1), normalize(v2))); /// 3.14159;
}

void main() {
  vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  vec2 pixel_position = pixel_coords / resolution;
  cam_pos = (cameraMatrix * vec4(0.0,0.0,0.0,1.0)).xyz;
  
  v00 = (vec4(v00,0.0) * cameraMatrix).xyz;
  v10 = (vec4(v10,0.0) * cameraMatrix).xyz;
  v01 = (vec4(v01,0.0) * cameraMatrix).xyz;
  v11 = (vec4(v11,0.0) * cameraMatrix).xyz;
  
  Ray ray = createRay(cam_pos, normalize( lerp4vec( v00, v10, v01, v11, pixel_position.x, pixel_position.y) ) );
  ray.direction.y *= -1;
  
  
	RayHit hit;
	float mult = 1.0;
	vec4 color = vec4(1.0,1.0,1.0, 1.0);
	for(int i = 0; i < 10; i ++) {
		hit.distance = 1.0 / 0.0;
		intersectGroundPlane(ray,0.0,hit);
		for(int s = 0; s < sphs.length(); s ++) {
			intersectSphere(ray, sphs[s], hit);
		}

		if(hit.distance != 1.0/0.0) {
			
			ray.direction = reflect(ray.direction,hit.normal);
			
			Ray toLight = Ray(vec3(hit.position + hit.normal * 0.00001),normalize(+light - hit.position));

			RayHit shadowHit;
			shadowHit.distance = 1.0/0.0;

			intersectGroundPlane(toLight,0.0,shadowHit);
			for(int s = 0; s < sphs.length(); s++) {
				intersectSphere(toLight, sphs[s], shadowHit);
			}
			
			if(shadowHit.distance != 1.0/0.0) {
				float shadowAngle = angleBetween(hit.normal, toLight.direction);
				mult *= 0.0;
			} 
			else {
				float angle = angleBetween(hit.normal,toLight.direction);
				mult *= cos(angle);
			}
			if(i == 0) color = hit.object.color;
			color = color * 0.5 + hit.object.color * 0.5;
			
			ray.origin = hit.position + hit.normal * 0.00001;
		}
		//else mult = 0.0;
	}
  	pixel = color * mult;
  imageStore(img_output, pixel_coords, pixel);
}
