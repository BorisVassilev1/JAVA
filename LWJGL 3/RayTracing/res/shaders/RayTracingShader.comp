#version 450

#ifdef GL_ES
precision highp float;
#endif

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform mat4 cameraMatrix;
uniform vec2 resolution;

vec3 cam_pos = vec3(0.0,0.0,0.0);

vec3 light = vec3(1.5,2.6,0.4);

vec3 v00 = vec3(-1.0,-1.0, 1.0);
vec3 v01 = vec3(-1.0, 1.0, 1.0);
vec3 v11 = vec3( 1.0, 1.0, 1.0);
vec3 v10 = vec3( 1.0,-1.0, 1.0);

struct Sphere {
	vec3 position;
	float radius;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};

Ray createRay(vec3 origin, vec3 direction) {
	Ray ray = Ray(origin, direction);
	return ray;
}

struct RayHit
{
    vec3 position;
    float distance;
    vec3 normal;
};

bool intersectSphere(in Ray ray, in Sphere sphere, inout RayHit hit) {
	// Calculate distance along the ray where the sphere is intersected
    vec3 d = ray.origin - sphere.position;
    float p1 = -dot(ray.direction, d);
    float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;
    if (p2sqr < 0)
        return false;
    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < hit.distance)
    {
        hit.distance = t;
        hit.position = ray.origin + t * ray.direction;
        hit.normal = normalize(hit.position - sphere.position);
    }
}

bool intersectGroundPlane(in Ray ray, in float PlaneHeight, inout RayHit hit) {
	
	float t = ray.origin.y / -ray.direction.y;
	if(t > 0 && t < hit.distance) {
		hit.position = ray.origin + ray.direction * t;
		hit.distance = t;
		hit.normal = vec3(0.0,1.0,0.0);
		return true;	
	}
	return false;
}

vec3 lerp4vec(vec3 v00, vec3 v10, vec3 v01, vec3 v11, float x, float y) {
	return mix(
	mix(v00,v10,x),
	mix(v01,v11,x),
	y
	);
}

Sphere sphs[3] = Sphere[3](
	Sphere(vec3(0.5,1.3,1.5),0.5),
	Sphere(vec3(1.3,0.2,2),0.7),
	Sphere(vec3(-0.4,0.5,2),0.5)
);

float angleBetween(vec3 v1, vec3 v2) {
    return acos(dot(normalize(v1), normalize(v2))) / 3.14;
}

void main() {
  vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  vec2 pixel_position = pixel_coords / resolution;
  cam_pos = (cameraMatrix * vec4(cam_pos,0.0)).xyz;
  Ray ray = createRay(cam_pos, normalize( lerp4vec( v00, v10, v01, v11, pixel_position.x, pixel_position.y) ) );
  ray.direction.y *= -1;
  //pixel = vec4(direction.direction.x, direction.direction.y, 1.0,1.0);
  
  
	RayHit hit;
	
	//for(int i = 0; i < 5; i ++) {
		hit.distance = 1.0 / 0.0;
		intersectGroundPlane(ray,0.0,hit);
		intersectSphere(ray, sphs[0], hit);
		intersectSphere(ray, sphs[1], hit);
		intersectSphere(ray, sphs[2], hit);
		//reflect(ray.direction,hit.normal);
		//ray.origin = hit.position;
	//}
  	pixel = vec4(hit.distance / 5, hit.distance / 5, hit.distance / 5,1.0);
  
  imageStore(img_output, pixel_coords, pixel);
}